# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.http_response import AsyncHttpResponse, HttpResponse
from ...core.jsonable_encoder import jsonable_encoder
from ...core.pagination import AsyncPager, BaseHttpResponse, SyncPager
from ...core.pydantic_utilities import parse_obj_as
from ...core.request_options import RequestOptions
from ...core.serialization import convert_and_respect_annotation_metadata
from ...errors.bad_request_error import BadRequestError
from ...types.bulk_create_entity_response import BulkCreateEntityResponse
from ...types.entity import Entity
from .types.entities_create_bulk_request_entities_item import EntitiesCreateBulkRequestEntitiesItem
from .types.entities_list_request_sort_by import EntitiesListRequestSortBy
from .types.entities_list_request_status import EntitiesListRequestStatus
from .types.entities_list_response import EntitiesListResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawEntitiesClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        entity_collection_id: str,
        *,
        page: typing.Optional[int] = None,
        page_limit: typing.Optional[int] = None,
        name: typing.Optional[str] = None,
        status: typing.Optional[EntitiesListRequestStatus] = None,
        sort_by: typing.Optional[EntitiesListRequestSortBy] = None,
        sort_option: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPager[Entity]:
        """
        This method returns a list of the entities in the specified entity collection.

        Parameters
        ----------
        entity_collection_id : str
            The unique identifier of the entity collection for which the platform will retrieve the entities.

        page : typing.Optional[int]
            A number that identifies the page to retrieve.

            **Default**: `1`.

        page_limit : typing.Optional[int]
            The number of items to return on each page.

            **Default**: `10`.
            **Max**: `50`.

        name : typing.Optional[str]
            Filter entities by name.

        status : typing.Optional[EntitiesListRequestStatus]
            Filter entities by status.

        sort_by : typing.Optional[EntitiesListRequestSortBy]
            The field to sort on. The following options are available:
            - `created_at`: Sorts by the time, in the RFC 3339 format ("YYYY-MM-DDTHH:mm:ssZ"), when the entity was created.
            - `updated_at:` Sorts by the time, in the RFC 3339 format ("YYYY-MM-DDTHH:mm:ssZ"), when the entity collection was updated.
            - `name`: Sorts by the name.

        sort_option : typing.Optional[str]
            The sorting direction. The following options are available:
            - `asc`
            - `desc`

            **Default**: `desc`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPager[Entity]
            The entities have been successfully retrieved.
        """
        page = page if page is not None else 1

        _response = self._client_wrapper.httpx_client.request(
            f"entity-collections/{jsonable_encoder(entity_collection_id)}/entities",
            method="GET",
            params={
                "page": page,
                "page_limit": page_limit,
                "name": name,
                "status": status,
                "sort_by": sort_by,
                "sort_option": sort_option,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    EntitiesListResponse,
                    parse_obj_as(
                        type_=EntitiesListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                _items = _parsed_response.data
                _has_next = True
                _get_next = lambda: self.list(
                    entity_collection_id,
                    page=page + 1,
                    page_limit=page_limit,
                    name=name,
                    status=status,
                    sort_by=sort_by,
                    sort_option=sort_option,
                    request_options=request_options,
                )
                return SyncPager(
                    has_next=_has_next, items=_items, get_next=_get_next, response=BaseHttpResponse(response=_response)
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create(
        self,
        entity_collection_id: str,
        *,
        name: str,
        asset_ids: typing.Sequence[str],
        description: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Entity]:
        """
        This method creates an entity within a specified entity collection. Each entity must be associated with at least one asset.

        Parameters
        ----------
        entity_collection_id : str
            The unique identifier of the entity collection in which to create the entity.

        name : str
            The name of the entity. Make sure you use a succinct and descriptive name.

        asset_ids : typing.Sequence[str]
            An array of asset IDs to associate with the entity. You must provide at least one value.

        description : typing.Optional[str]
            An optional description of the entity.

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Optional metadata for the entity, provided as key-value pairs to store additional context or attributes. Use metadata to categorize or describe the entity for easier management and search. Keys must be of type `string`, and values can be of type `string`, `integer`, `float`, or `boolean`.

            **Example**:
            ```json
            {
              "sport": "soccer",
              "teamId": 42,
              "performanceScore": 8.7,
              "isActive": true
            }
            ```

            <Note title="Note">
              To store complex data types such as objects or arrays, convert them to string values before including them in the metadata.
            </Note>

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Entity]
            The entity has been successfully created.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"entity-collections/{jsonable_encoder(entity_collection_id)}/entities",
            method="POST",
            json={
                "name": name,
                "description": description,
                "metadata": metadata,
                "asset_ids": asset_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Entity,
                    parse_obj_as(
                        type_=Entity,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_bulk(
        self,
        entity_collection_id: str,
        *,
        entities: typing.Sequence[EntitiesCreateBulkRequestEntitiesItem],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BulkCreateEntityResponse]:
        """
        This method creates multiple entities within a specified entity collection in a single request. Each entity must be associated with at least one asset. This endpoint is useful for efficiently adding multiple entities, such as a roster of players or a group of characters.

        Parameters
        ----------
        entity_collection_id : str
            The unique identifier of the entity collection in which to create the entities.

        entities : typing.Sequence[EntitiesCreateBulkRequestEntitiesItem]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BulkCreateEntityResponse]
            The entities have been successfully created.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"entity-collections/{jsonable_encoder(entity_collection_id)}/entities/bulk",
            method="POST",
            json={
                "entities": convert_and_respect_annotation_metadata(
                    object_=entities,
                    annotation=typing.Sequence[EntitiesCreateBulkRequestEntitiesItem],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BulkCreateEntityResponse,
                    parse_obj_as(
                        type_=BulkCreateEntityResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def retrieve(
        self, entity_collection_id: str, entity_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[Entity]:
        """
        This method retrieves details about the specified entity.

        Parameters
        ----------
        entity_collection_id : str
            The unique identifier of the entity collection.

        entity_id : str
            The unique identifier of the entity to retrieve.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Entity]
            The entity has been successfully retrieved.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"entity-collections/{jsonable_encoder(entity_collection_id)}/entities/{jsonable_encoder(entity_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Entity,
                    parse_obj_as(
                        type_=Entity,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete(
        self, entity_collection_id: str, entity_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        This method deletes a specific entity from an entity collection. It permanently removes the entity and its associated data, but does not affect the assets associated with this entity.

        Parameters
        ----------
        entity_collection_id : str
            The unique identifier of the entity collection containing the entity to be deleted.

        entity_id : str
            The unique identifier of the entity to delete.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"entity-collections/{jsonable_encoder(entity_collection_id)}/entities/{jsonable_encoder(entity_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update(
        self,
        entity_collection_id: str,
        entity_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Entity]:
        """
        This method updates the specified entity within an entity collection. This operation allows modification of the entity's name, description, or metadata. Note that this endpoint does not affect the assets associated with the entity.

        Parameters
        ----------
        entity_collection_id : str
            The unique identifier of the entity collection containing the entity to be updated.

        entity_id : str
            The unique identifier of the entity to update.

        name : typing.Optional[str]
            The new name for the entity.

        description : typing.Optional[str]
            An updated description for the entity.

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Updated metadata for the entity. If provided, this completely replaces the existing metadata. Use this to store custom key-value pairs related to the entity.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Entity]
            The entity has been successfully updated.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"entity-collections/{jsonable_encoder(entity_collection_id)}/entities/{jsonable_encoder(entity_id)}",
            method="PATCH",
            json={
                "name": name,
                "description": description,
                "metadata": metadata,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Entity,
                    parse_obj_as(
                        type_=Entity,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_assets(
        self,
        entity_collection_id: str,
        entity_id: str,
        *,
        asset_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Entity]:
        """
        This method adds assets to the specified entity within an entity collection. Assets are used to identify the entity in media content, and adding multiple assets can improve the accuracy of entity recognition in searches.

        When assets are added, the entity may temporarily enter the "processing" state while the platform updates the necessary data. Once processing is complete, the entity status will return to "ready."

        Parameters
        ----------
        entity_collection_id : str
            The unique identifier of the entity collection that contains the entity to which assets will be added.

        entity_id : str
            The unique identifier of the entity within the specified entity collection to which the assets will be added.

        asset_ids : typing.Sequence[str]
            An array of asset IDs to add to the entity.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Entity]
            The assets have been successfully added to the entity.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"entity-collections/{jsonable_encoder(entity_collection_id)}/entities/{jsonable_encoder(entity_id)}/assets",
            method="POST",
            json={
                "asset_ids": asset_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Entity,
                    parse_obj_as(
                        type_=Entity,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_assets(
        self,
        entity_collection_id: str,
        entity_id: str,
        *,
        asset_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Entity]:
        """
        This method removes from the specified entity. Assets are used to identify the entity in media content, and removing assets may impact the accuracy of entity recognition in searches if too few assets remain.

        When assets are removed, the entity may temporarily enter a "processing" state while the system updates the necessary data. Once processing is complete, the entity status will return to "ready."

        <Note title="Notes">
          - This operation only removes the association between the entity and the specified assets; it does not delete the assets themselves.
          - An entity must always have at least one asset associated with it. You can't remove the last asset from an entity.
        </Note>

        Parameters
        ----------
        entity_collection_id : str
            The unique identifier of the entity collection that contains the entity from which assets will be removed.

        entity_id : str
            The unique identifier of the entity within the specified entity collection from which the assets will be removed.

        asset_ids : typing.Sequence[str]
            An array of asset IDs to remove from the entity.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Entity]
            The assets have been successfully removed from the entity.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"entity-collections/{jsonable_encoder(entity_collection_id)}/entities/{jsonable_encoder(entity_id)}/assets",
            method="DELETE",
            json={
                "asset_ids": asset_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Entity,
                    parse_obj_as(
                        type_=Entity,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawEntitiesClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        entity_collection_id: str,
        *,
        page: typing.Optional[int] = None,
        page_limit: typing.Optional[int] = None,
        name: typing.Optional[str] = None,
        status: typing.Optional[EntitiesListRequestStatus] = None,
        sort_by: typing.Optional[EntitiesListRequestSortBy] = None,
        sort_option: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPager[Entity]:
        """
        This method returns a list of the entities in the specified entity collection.

        Parameters
        ----------
        entity_collection_id : str
            The unique identifier of the entity collection for which the platform will retrieve the entities.

        page : typing.Optional[int]
            A number that identifies the page to retrieve.

            **Default**: `1`.

        page_limit : typing.Optional[int]
            The number of items to return on each page.

            **Default**: `10`.
            **Max**: `50`.

        name : typing.Optional[str]
            Filter entities by name.

        status : typing.Optional[EntitiesListRequestStatus]
            Filter entities by status.

        sort_by : typing.Optional[EntitiesListRequestSortBy]
            The field to sort on. The following options are available:
            - `created_at`: Sorts by the time, in the RFC 3339 format ("YYYY-MM-DDTHH:mm:ssZ"), when the entity was created.
            - `updated_at:` Sorts by the time, in the RFC 3339 format ("YYYY-MM-DDTHH:mm:ssZ"), when the entity collection was updated.
            - `name`: Sorts by the name.

        sort_option : typing.Optional[str]
            The sorting direction. The following options are available:
            - `asc`
            - `desc`

            **Default**: `desc`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPager[Entity]
            The entities have been successfully retrieved.
        """
        page = page if page is not None else 1

        _response = await self._client_wrapper.httpx_client.request(
            f"entity-collections/{jsonable_encoder(entity_collection_id)}/entities",
            method="GET",
            params={
                "page": page,
                "page_limit": page_limit,
                "name": name,
                "status": status,
                "sort_by": sort_by,
                "sort_option": sort_option,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    EntitiesListResponse,
                    parse_obj_as(
                        type_=EntitiesListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                _items = _parsed_response.data
                _has_next = True

                async def _get_next():
                    return await self.list(
                        entity_collection_id,
                        page=page + 1,
                        page_limit=page_limit,
                        name=name,
                        status=status,
                        sort_by=sort_by,
                        sort_option=sort_option,
                        request_options=request_options,
                    )

                return AsyncPager(
                    has_next=_has_next, items=_items, get_next=_get_next, response=BaseHttpResponse(response=_response)
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create(
        self,
        entity_collection_id: str,
        *,
        name: str,
        asset_ids: typing.Sequence[str],
        description: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Entity]:
        """
        This method creates an entity within a specified entity collection. Each entity must be associated with at least one asset.

        Parameters
        ----------
        entity_collection_id : str
            The unique identifier of the entity collection in which to create the entity.

        name : str
            The name of the entity. Make sure you use a succinct and descriptive name.

        asset_ids : typing.Sequence[str]
            An array of asset IDs to associate with the entity. You must provide at least one value.

        description : typing.Optional[str]
            An optional description of the entity.

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Optional metadata for the entity, provided as key-value pairs to store additional context or attributes. Use metadata to categorize or describe the entity for easier management and search. Keys must be of type `string`, and values can be of type `string`, `integer`, `float`, or `boolean`.

            **Example**:
            ```json
            {
              "sport": "soccer",
              "teamId": 42,
              "performanceScore": 8.7,
              "isActive": true
            }
            ```

            <Note title="Note">
              To store complex data types such as objects or arrays, convert them to string values before including them in the metadata.
            </Note>

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Entity]
            The entity has been successfully created.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"entity-collections/{jsonable_encoder(entity_collection_id)}/entities",
            method="POST",
            json={
                "name": name,
                "description": description,
                "metadata": metadata,
                "asset_ids": asset_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Entity,
                    parse_obj_as(
                        type_=Entity,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_bulk(
        self,
        entity_collection_id: str,
        *,
        entities: typing.Sequence[EntitiesCreateBulkRequestEntitiesItem],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BulkCreateEntityResponse]:
        """
        This method creates multiple entities within a specified entity collection in a single request. Each entity must be associated with at least one asset. This endpoint is useful for efficiently adding multiple entities, such as a roster of players or a group of characters.

        Parameters
        ----------
        entity_collection_id : str
            The unique identifier of the entity collection in which to create the entities.

        entities : typing.Sequence[EntitiesCreateBulkRequestEntitiesItem]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BulkCreateEntityResponse]
            The entities have been successfully created.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"entity-collections/{jsonable_encoder(entity_collection_id)}/entities/bulk",
            method="POST",
            json={
                "entities": convert_and_respect_annotation_metadata(
                    object_=entities,
                    annotation=typing.Sequence[EntitiesCreateBulkRequestEntitiesItem],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BulkCreateEntityResponse,
                    parse_obj_as(
                        type_=BulkCreateEntityResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def retrieve(
        self, entity_collection_id: str, entity_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[Entity]:
        """
        This method retrieves details about the specified entity.

        Parameters
        ----------
        entity_collection_id : str
            The unique identifier of the entity collection.

        entity_id : str
            The unique identifier of the entity to retrieve.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Entity]
            The entity has been successfully retrieved.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"entity-collections/{jsonable_encoder(entity_collection_id)}/entities/{jsonable_encoder(entity_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Entity,
                    parse_obj_as(
                        type_=Entity,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete(
        self, entity_collection_id: str, entity_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        This method deletes a specific entity from an entity collection. It permanently removes the entity and its associated data, but does not affect the assets associated with this entity.

        Parameters
        ----------
        entity_collection_id : str
            The unique identifier of the entity collection containing the entity to be deleted.

        entity_id : str
            The unique identifier of the entity to delete.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"entity-collections/{jsonable_encoder(entity_collection_id)}/entities/{jsonable_encoder(entity_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update(
        self,
        entity_collection_id: str,
        entity_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Entity]:
        """
        This method updates the specified entity within an entity collection. This operation allows modification of the entity's name, description, or metadata. Note that this endpoint does not affect the assets associated with the entity.

        Parameters
        ----------
        entity_collection_id : str
            The unique identifier of the entity collection containing the entity to be updated.

        entity_id : str
            The unique identifier of the entity to update.

        name : typing.Optional[str]
            The new name for the entity.

        description : typing.Optional[str]
            An updated description for the entity.

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Updated metadata for the entity. If provided, this completely replaces the existing metadata. Use this to store custom key-value pairs related to the entity.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Entity]
            The entity has been successfully updated.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"entity-collections/{jsonable_encoder(entity_collection_id)}/entities/{jsonable_encoder(entity_id)}",
            method="PATCH",
            json={
                "name": name,
                "description": description,
                "metadata": metadata,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Entity,
                    parse_obj_as(
                        type_=Entity,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_assets(
        self,
        entity_collection_id: str,
        entity_id: str,
        *,
        asset_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Entity]:
        """
        This method adds assets to the specified entity within an entity collection. Assets are used to identify the entity in media content, and adding multiple assets can improve the accuracy of entity recognition in searches.

        When assets are added, the entity may temporarily enter the "processing" state while the platform updates the necessary data. Once processing is complete, the entity status will return to "ready."

        Parameters
        ----------
        entity_collection_id : str
            The unique identifier of the entity collection that contains the entity to which assets will be added.

        entity_id : str
            The unique identifier of the entity within the specified entity collection to which the assets will be added.

        asset_ids : typing.Sequence[str]
            An array of asset IDs to add to the entity.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Entity]
            The assets have been successfully added to the entity.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"entity-collections/{jsonable_encoder(entity_collection_id)}/entities/{jsonable_encoder(entity_id)}/assets",
            method="POST",
            json={
                "asset_ids": asset_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Entity,
                    parse_obj_as(
                        type_=Entity,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_assets(
        self,
        entity_collection_id: str,
        entity_id: str,
        *,
        asset_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Entity]:
        """
        This method removes from the specified entity. Assets are used to identify the entity in media content, and removing assets may impact the accuracy of entity recognition in searches if too few assets remain.

        When assets are removed, the entity may temporarily enter a "processing" state while the system updates the necessary data. Once processing is complete, the entity status will return to "ready."

        <Note title="Notes">
          - This operation only removes the association between the entity and the specified assets; it does not delete the assets themselves.
          - An entity must always have at least one asset associated with it. You can't remove the last asset from an entity.
        </Note>

        Parameters
        ----------
        entity_collection_id : str
            The unique identifier of the entity collection that contains the entity from which assets will be removed.

        entity_id : str
            The unique identifier of the entity within the specified entity collection from which the assets will be removed.

        asset_ids : typing.Sequence[str]
            An array of asset IDs to remove from the entity.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Entity]
            The assets have been successfully removed from the entity.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"entity-collections/{jsonable_encoder(entity_collection_id)}/entities/{jsonable_encoder(entity_id)}/assets",
            method="DELETE",
            json={
                "asset_ids": asset_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Entity,
                    parse_obj_as(
                        type_=Entity,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
